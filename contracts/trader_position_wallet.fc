#pragma version >=0.4.1;

#include "shared/stdlib.fc";
#include "shared/messages.fc";

#include "trader_position_wallet/storage.fc";
#include "trader_position_wallet/op-codes.fc";


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_addr = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::start_increase_position) {
        var (slice trader_addr, slice vamm_addr, int is_busy, _) = load_data();
        throw_unless(400, equal_slices(sender_addr, vamm_addr));

        cell new_position_ref = in_msg_body.preload_ref();

        save_data(trader_addr, vamm_addr, 0, new_position_ref);
        return ();
    }

    if (op == op::update_position) {
        var (slice trader_addr, slice vamm_addr, int is_busy, _) = load_data();
        throw_unless(400, equal_slices(sender_addr, vamm_addr));

        cell new_position_ref = in_msg_body.preload_ref();

        save_data(trader_addr, vamm_addr, 0, new_position_ref);
        return ();
    }

    throw(0xffff); 
}


(slice, slice, int, cell) get_position_data() method_id {
    return load_data();
}