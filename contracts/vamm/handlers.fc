#include "../shared/stdlib.fc";

#include "./constants.fc";
#include "./storage.fc";
#include "./errors.fc";
#include "./utils.fc";
#include "./requests.fc";

() handle::transfer_notification(slice in_msg_body, slice sender_addr, int query_id) impure inline {
  var (int jetton_amount, slice from_addr, cell payload_ref) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr(), in_msg_body.preload_ref());

  var (slice oracle_addr, slice jetton_wallet_addr, cell position_wallet_code) = select_transfer_data();

  throw_unless(error::invalid_jetton, equal_slices(sender_addr, jetton_wallet_addr));

  slice payload_s = payload_ref.begin_parse();
  int payload_op = payload_s~load_uint(32);
        
  if ((payload_op == op::increase_position) | (payload_op == op::add_margin)) {
    throw_unless(error::invalid_jetton_amount, jetton_amount > 0);

    var (cell position_state_init, slice trader_position_addr) = get_position_state_init_and_address(position_wallet_code, my_address(), from_addr);

    request_position_and_price_with_amount(oracle_addr, payload_op, query_id, jetton_amount, payload_s, trader_position_addr, position_state_init);
    return ();
  }

  throw(error::wrong_op);
}

() handle::increase_position(slice in_msg_body, slice sender_addr, int query_id, int msg_value) impure inline {
  ;; TODO check if mesage was sent from correct position address
  var (cell payload_ref, cell position_ref, cell new_price_ref) = (in_msg_body~load_ref(), in_msg_body~load_ref(), in_msg_body.preload_ref());

  slice oracle_data_s = new_price_ref.begin_parse();
  int new_price = oracle_data_s~load_coins();
  syncTerminalPriceToOracle(new_price);

  slice position_s = position_ref.begin_parse();
  slice payload_s = payload_ref.begin_parse();

  ;; TODO: msg layout
  int raw_amount = in_msg_body~load_coins();

  var (int direction, int leverage, int min_base_asset_amount) = (payload_s~load_uint(1), payload_s~load_uint(32), payload_s~load_coins());
  ;; int direction = payload_s~load_uint(1);
  ;; int leverage = payload_s~load_uint(32);
  ;; int min_base_asset_amount = payload_s~load_coins();

  ;; Check...
  ;; TODO: check asset on router

  ~dump(leverage);
  ~dump(direction);
  ~dump(min_base_asset_amount);
  ~dump(500);

  if (~ requireMoreMarginRatio(divd(DECIMAL_UNIT, leverage), db::initMarginRatio, true)) {
    int withdraw_ton_amount = 120000000; ;; TODO: calculate gas fee from config

    int unlock_ton_amount = msg_value - withdraw_ton_amount;


    ~dump(leverage);
    ~dump(direction);
    ~dump(min_base_asset_amount);
    ~dump(unlock_ton_amount);
    ~dump(401);

    request_withdraw(query_id, raw_amount, position_s~load_msg_addr(), withdraw_ton_amount, mode::normal + mode::ignore_errors);
    ;; withdraw(position_s~load_msg_addr(), raw_amount, withdraw_ton_amount, mode::normal);
    unlock_position(sender_addr, unlock_ton_amount, mode::normal + mode::ignore_errors);
    return ();
  }
  ;; TODO: fee calculations    

  int _amount = raw_amount.divd(muld(db::fee, leverage) + DECIMAL_UNIT);

  var (slice trader_addr,
    int old_position_size,
    int old_position_margin,
    int old_position_open_notional,
    int old_position_last_updated_cumulative_premium,
    int old_position_fee,
    int old_position_last_updated_timestamp) = unpack_position_data(position_s);


  int isNewPosition = old_position_size == 0;
  int isSameDirection = old_position_size > 0 ? direction == direction::long : direction == direction::short;
  int expandExisting = (~ isNewPosition) & isSameDirection;
  int isAdd = direction == direction::long;


  if (~ (isNewPosition | expandExisting)) {
    ~dump(402);
    ;; TODO: cant throw, revert amount back and unlock position
    ;; int storage_ton = 100000000; ;; 0.1
    ;; raw_reserve(storage_ton, 0);

    int withdraw_ton_amount = 120000000; ;; TODO: 

    int unlock_ton_amount = msg_value - withdraw_ton_amount;

    request_withdraw(query_id, raw_amount, trader_addr, withdraw_ton_amount,mode::normal);

    ;; withdraw(trader_addr, raw_amount, withdraw_ton_amount, mode::normal);
    unlock_position(sender_addr, unlock_ton_amount, mode::normal);
    return ();
  }

  int openNotional = muld(_amount, leverage);
  var ( 
    int amountBaseAssetBought,
    int quoteAssetReserveAfter, 
    int baseAssetReserveAfter
  ) = swapInput(isAdd, openNotional);

  ;; TODO: check min base amount 
  ;; throw("Limit error: " + abs(amountBaseAssetBought).toString() + " < " + _minBaseAssetAmount.toString())

  int newPositionSize = old_position_size + amountBaseAssetBought;
  int totalLongOpenInterestAfter = db::openInterestLong + (newPositionSize > 0 ? openNotional : 0);
  int totalShortOpenInterestAfter = db::openInterestShort + (newPositionSize < 0 ? openNotional : 0);

  var (int remainMargin, int x1, int x2, int rolloverFee) = calcRemainMarginWithFundingPaymentAndRolloverFee(
    old_position_size, 
    old_position_margin, 
    old_position_last_updated_cumulative_premium,
    old_position_last_updated_timestamp,
    _amount
  );

  int newPositionMargin = remainMargin;
  int newPositionOpenNotional = old_position_open_notional + openNotional;
        
  int newPositionLatestCPF = latestCumulativePremiumFraction(newPositionSize);

  db::totalLongPositionSize += newPositionSize > 0 ? abs(amountBaseAssetBought) : 0;
  db::totalShortPositionSize += newPositionSize < 0 ? abs(amountBaseAssetBought) : 0;
  db::openInterestLong = totalLongOpenInterestAfter;
  db::openInterestShort = totalShortOpenInterestAfter;

  db::quoteAssetReserve = quoteAssetReserveAfter;
  db::baseAssetReserve = baseAssetReserveAfter;
  db::balance += _amount;


  cell new_position_ref = pack_position_data(trader_addr, newPositionSize, newPositionMargin, newPositionOpenNotional, newPositionLatestCPF, get_position_fee(old_position_fee), now());
  ;; TODO: calculate value and mode
  update_position(new_position_ref, op::increase_position, query_id, sender_addr, 0, mode::carry_remaining_gas);

  ;; TODO: need this?
  ;; raw_reserve(100000, 0);

  ;; TODO: other messages: Vault, excesses, etc.

  {-
    let (feeToStakers, feeToVault) = distributeFee(feeAmount + rolloverFee)
    
    strict stake = if (_amount >= rolloverFee) then {
      invoke(
        vaultAddress(),
        "addLocked",
        [],
        [AttachedPayment(quoteAsset(), _amount - rolloverFee)]
      )
    } else {
      invoke(
        vaultAddress(),
        "withdrawLocked",
        [rolloverFee - _amount],
        []
      )
    }

    strict depositVault = invoke(
      vaultAddress(),
      "addFree",
      [],
      [AttachedPayment(quoteAsset(), feeToVault)]
    )
  -}

  ~dump(666);
        
  save_data();
}

() handle::close_position(slice in_msg_body, slice sender_addr, int query_id, int my_balance, int msg_value) impure inline {

  var (cell payload_ref, cell position_ref, cell new_price_ref) = (in_msg_body~load_ref(), in_msg_body~load_ref(), in_msg_body.preload_ref());

  slice oracle_s = new_price_ref.begin_parse();
  int new_price = oracle_s~load_coins();
  syncTerminalPriceToOracle(new_price);
  ~dump(70000);
  ~dump(new_price);
  ~dump(db::quoteAssetWeight);

  slice position_s = position_ref.begin_parse();
  slice payload_s = payload_ref.begin_parse();

  ;; TODO: msg layout

  var (int _size, int _minQuoteAssetAmount, int _addToMargin) = (payload_s~load_int(128), payload_s~load_coins(), payload_s~load_int(1));

  slice position_s = position_ref.begin_parse();

  var (slice trader_addr,
    int oldPositionSize,
    int oldPositionMargin,
    int oldPositionOpenNotional,
    int oldPositionLastUpdatedCPF,
    int oldPositionFee,
    int oldPositionTimestamp) = unpack_position_data(position_s);


  ~dump(888);

  ifnot ((_size <= abs(oldPositionSize)) & (_size > 0)) {
    ~dump(889);
    ~dump(_size);
    ~dump(abs(oldPositionSize));
    ~dump((_size <= abs(oldPositionSize)));
    unlock_position(sender_addr, 0, mode::carry_remaining_gas);
    return ();
  }

  var (
    int newPositionSize,
    int newPositionMargin,
    int newPositionOpenNotional,
    int newPositionLstUpdCPF,
    int positionBadDebt,
    int realizedPnl,
    int marginToTrader,
    int quoteAssetReserveAfter,
    int baseAssetReserveAfter,
    int totalLongAfter,
    int totalShortAfter,
    int totalLongOpenInterestAfter,
    int totalShortOpenInterestAfter,
    int realizedFee,
    int exchangedQuoteAssetAmount
  ) = internalClosePosition(
    oldPositionSize,
    oldPositionMargin,
    oldPositionOpenNotional,
    oldPositionLastUpdatedCPF, 
    oldPositionTimestamp,
    _size,
    oldPositionFee,
    _minQuoteAssetAmount,
    _addToMargin,
    true,
    false,
    new_price
  );

  if ((positionBadDebt > 0) | (oldPositionTimestamp >= now())) {
    ;; TODO: throw exception
    ~dump(positionBadDebt);
    ~dump(oldPositionTimestamp);
    ~dump(406);
    unlock_position(sender_addr, 0, mode::carry_remaining_gas);
    return ();
  }
        
  int withdrawAmount = marginToTrader + realizedFee;
  int ammBalance = db::balance - withdrawAmount;
      
  ;;   strict unstake = invoke(
  ;;     vaultAddress(),
  ;;     "withdrawLocked",
  ;;     [withdrawAmount],
  ;;     []
  ;;   )

  ;; var (int feeToStakers, int feeToVault) = distributeFee(realizedFee);

  ;;       strict depositVault = invoke(
  ;;     vaultAddress(),
  ;;     "addFree",
  ;;     [],
  ;;     [AttachedPayment(quoteAsset(), feeToVault)]
  ;;   )

  ~dump(888);
  ~dump(marginToTrader);

  ;; raw_reserve(mint_storage_tons, 0);

  int mint_storage_tons = 50000000;
  int value_to_sent = my_balance - mint_storage_tons;

  if (marginToTrader > 0) {
    ~dump(999);
    int withdraw_ton = 110000000;
    value_to_sent -= withdraw_ton;
    ;; TODO: calculate value and mode
    ;; 0.1ton
    request_withdraw(query_id, marginToTrader, trader_addr, withdraw_ton, mode::normal);
    ;; withdraw(trader_addr, marginToTrader, withdraw_ton, mode::normal);
  }

  ;; TODO: calculate value and mode

  ;; TODO: need this? 

  db::quoteAssetReserve = quoteAssetReserveAfter;
  db::baseAssetReserve = baseAssetReserveAfter;
  db::totalLongPositionSize = totalLongAfter;
  db::totalShortPositionSize = totalShortAfter;
  db::openInterestLong = totalLongOpenInterestAfter;
  db::openInterestShort = totalShortOpenInterestAfter;

  db::balance = max(ammBalance, 0);

  ~dump(888999);
  ~dump(db::fee);

  cell new_position_ref = pack_position_data(newPositionSize != 0 ? (trader_addr, newPositionSize, newPositionMargin, newPositionOpenNotional, newPositionLstUpdCPF, get_position_fee(oldPositionFee), now()) : (trader_addr, 0, 0, 0, 0, 0, 0));
  update_position(new_position_ref, op::close_position, query_id, sender_addr, value_to_sent, mode::normal);
  ;;   TODO: transfer fee here
  ;;   transferFee(feeToStakers)
  save_data();
}

() handle::add_margin(slice in_msg_body, slice sender_addr, int query_id, int msg_value) impure inline {
  var (int _amount, cell position_ref, cell new_price_ref) = (in_msg_body~load_coins(), in_msg_body~load_ref(), in_msg_body.preload_ref());

  slice oracle_s = new_price_ref.begin_parse();
  int new_price = oracle_s~load_coins();
  syncTerminalPriceToOracle(new_price);

  slice position_s = position_ref.begin_parse();

  ;; TODO: msg layout

  if ( ~ requireOpenPosition(position_s)) {
    ~dump(405);
    ;; TODO: cant throw, revert amount back 
    ;; throw("Invalid addMargin parameters")
    int withdraw_ton_amount = 120000000; ;; TODO: calc withdraw_ton_amount gas fees from config

    int unlock_ton_amount = msg_value - withdraw_ton_amount;

    request_withdraw(query_id, _amount, position_s~load_msg_addr(), withdraw_ton_amount, mode::normal);

    ;; withdraw(position_s~load_msg_addr(), _amount, withdraw_ton_amount, mode::normal);
    unlock_position(sender_addr, unlock_ton_amount, mode::normal);
    return ();
  }

  var (slice trader_addr,
    int oldPositionSize,
    int oldPositionMargin,
    int oldPositionOpenNotional,
    int oldPositionLastUpdatedCPF,
    int oldPositionFee,
    int oldPositionTimestamp) = unpack_position_data(position_s);

  ;;     strict stake = invoke(
  ;;   vaultAddress(),
  ;;   "addLocked",
  ;;   [],
  ;;   [AttachedPayment(quoteAsset(), _amount)]
  ;; )

  int rolloverFee = calcRolloverFee(oldPositionMargin, oldPositionTimestamp);

  if (rolloverFee > 0) {
    ;; TODO: 
    ;;         let (feeToStakers, feeToVault) = distributeFee(rolloverFee)

    ;;   strict unstake = invoke(
    ;;     vaultAddress(),
    ;;     "withdrawLocked",
    ;;     [feeToStakers],
    ;;     []
    ;;   )

    ;;   strict lockBadDebt = invoke(
    ;;     vaultAddress(),
    ;;     "exchangeFreeAndLocked",
    ;;     [-feeToVault], # Negative, because it is directed towards vault, not towards traders
    ;;     []
    ;;   )

    ;;   transferFee(feeToStakers)
  }

  db::balance += (_amount - rolloverFee);

  int newPositionMargin = oldPositionMargin - rolloverFee + _amount;
  cell new_position_ref = pack_position_data(trader_addr, oldPositionSize, newPositionMargin, oldPositionOpenNotional, oldPositionLastUpdatedCPF, get_position_fee(oldPositionFee), now());
  ;; TODO: calculate value and mode
  update_position(new_position_ref, op::add_margin, query_id, sender_addr, 0, mode::carry_remaining_gas);

  ;; TODO: vault/fee actions here doTransferFeeToStakers
  save_data();
}

() handle::remove_margin(slice in_msg_body, slice sender_addr, int query_id) impure inline {
  var (int _amount, cell position_ref, cell new_price_ref) = (in_msg_body~load_coins(), in_msg_body~load_ref(), in_msg_body.preload_ref());

  slice oracle_s = new_price_ref.begin_parse();
  int new_price = oracle_s~load_coins();
  syncTerminalPriceToOracle(new_price);

  slice position_s = position_ref.begin_parse();

  if (_amount <= 0 | ~ requireOpenPosition(position_s)) {
    ;; TODO: test throwing with unlocking position on bounce
    unlock_position(sender_addr, 0, mode::carry_remaining_gas);
    return ();
  }

  var (slice trader_addr,
    int oldPositionSize,
    int oldPositionMargin,
    int oldPositionOpenNotional,
    int oldPositionLastUpdatedCPF,
    int oldPositionFee,
    int oldPositionTimestamp) = unpack_position_data(position_s);

  var (int remainMargin, int badDebt, int fundingPayment, int rolloverFee) =
        calcRemainMarginWithFundingPaymentAndRolloverFee(
    oldPositionSize,
    oldPositionMargin,
    oldPositionLastUpdatedCPF,
    oldPositionTimestamp,
    - _amount
  );

  if (badDebt != 0)  {
    ;;   throw("Invalid removed margin amount")
  }
  int marginRatio = calcMarginRatio(remainMargin, badDebt, oldPositionOpenNotional);

  if (~ requireMoreMarginRatio(marginRatio, db::initMarginRatio, true))  {
    ;; throw("Too much margin removed: " + marginRatio.toString() + " < " + initMarginRatio().toString())
  } 

  ;;    strict doTransferFeeToStakers = if (rolloverFee > 0) then {
  ;;   strict lockBadDebt = invoke(
  ;;     vaultAddress(),
  ;;     "exchangeFreeAndLocked",
  ;;     [-feeToVault], # Negative, because it is directed towards vault, not towards traders
  ;;     []
  ;;   )
  ;;   transferFee(feeToStakers)

  ;; strict unstake = invoke(
  ;;   vaultAddress(),
  ;;   "withdrawLocked",
  ;;   [_amount + feeToStakers],
  ;;   []
  ;; )

  
  request_withdraw(query_id, _amount, trader_addr, 10000000, mode::normal);
  cell new_position_ref = pack_position_data(trader_addr, oldPositionSize, remainMargin, oldPositionOpenNotional, latestCumulativePremiumFraction(oldPositionSize), get_position_fee(oldPositionFee), now());
  ;; TODO: calculate value and mode
  update_position(new_position_ref, op::remove_margin, query_id, sender_addr, 0, mode::carry_remaining_gas);
  ;; TODO: withdraw here 
  ;; withdraw(i.caller, _amount)

  db::balance -= (_amount + rolloverFee);

  ;; doTransferFeeToStakers

  save_data();
}

() handle::pay_funding(slice in_msg_body, slice sender_addr, int query_id) impure inline {
  throw_if(600, now() < db::nextFundingBlockTimestamp);

  cell new_price_ref = in_msg_body.preload_ref();

  slice oracle_s = new_price_ref.begin_parse();
  int new_price = oracle_s~load_coins();
  syncTerminalPriceToOracle(new_price);

  var (int shortPremiumFraction, int longPremiumFraction, int premiumToVault) = getFunding(new_price);

  ~dump(3333);
  ~dump(shortPremiumFraction);
  ~dump(longPremiumFraction);

  ;;         strict doPayFundingToVault = if (premiumToVault > 0) then {
  ;;   strict doPayFundingToVault = invoke(
  ;;     vaultAddress(),
  ;;     "exchangeFreeAndLocked",
  ;;     [-premiumToVault], # Negative, because it is directed towards vault, not towards traders
  ;;     []
  ;;   )
  ;;   []
  ;; } else {
  ;;   []
  ;; }

  db::nextFundingBlockTimestamp += fundingPeriodRaw * SECONDS;
  db::latestLongCumulativePremiumFraction += longPremiumFraction;
  db::latestShortCumulativePremiumFraction += shortPremiumFraction;
  db::longFundingRate = divd(longPremiumFraction, new_price);
  db::shortFundingRate = divd(shortPremiumFraction, new_price);

  var body = begin_cell()
    .store_uint(op::update_amm, 32) ;; 0xe434967e
    .store_uint(query_id, 64)
    .store_uint(op::pay_funding, 32) ;; 0xb652c441
    .store_uint(db::nextFundingBlockTimestamp, 32)
    .store_coins(db::latestLongCumulativePremiumFraction)
    .store_coins(db::latestShortCumulativePremiumFraction);

  send_simple_message(0, sender_addr, body, mode::carry_remaining_gas + mode::ignore_errors);

  save_data();
}

() handle::liquidate(slice in_msg_body, slice sender_addr, int query_id, int msg_value) impure inline {
  var (slice liquidator_addr, cell position_ref, cell new_price_ref) = (in_msg_body~load_msg_addr(), in_msg_body~load_ref(), in_msg_body.preload_ref());

  slice oracle_s = new_price_ref.begin_parse();
  int new_price = oracle_s~load_coins();
  syncTerminalPriceToOracle(new_price);

  slice position_s = position_ref.begin_parse();

  var (slice trader_addr,
    int oldPositionSize,
    int oldPositionMargin,
    int oldPositionOpenNotional,
    int oldPositionLastUpdatedCPF,
    int oldPositionFee,
    int oldPositionTimestamp) = unpack_position_data(position_s);

  ;; ~dump(first(parse_addr(trader_addr)));
  ;; ~dump(oldPositionSize);
  ;; ~dump(oldPositionMargin);
  ;; ~dump(oldPositionOpenNotional);
  ;; ~dump(oldPositionLastUpdatedCPF);


  if (oldPositionSize == 0) {
    ;; "Unable to liquidate"
    unlock_position(sender_addr, 0, mode::carry_remaining_gas);
    return ();
  }

  int spotMarginRatio = getMarginRatioByOption(oldPositionSize, oldPositionMargin, oldPositionOpenNotional, oldPositionLastUpdatedCPF, oldPositionTimestamp, PNL_OPTION_SPOT, new_price);
  int liquidationMarginRatio = isOverFluctuationLimit(new_price) ? max(spotMarginRatio, getMarginRatioByOption(oldPositionSize, oldPositionMargin, oldPositionOpenNotional, oldPositionLastUpdatedCPF, oldPositionTimestamp, PNL_OPTION_ORACLE, new_price)) : spotMarginRatio;

  ;; !requireMoreMarginRatio(liquidationMarginRatio, maintenanceMarginRatio(), false)
  ;; || !requireOpenPosition(_trader)
  ;; || !initialized()
  ;; || paused()
  ;; || isMarketClosed()
  if (~ requireMoreMarginRatio(liquidationMarginRatio, db::maintenanceMarginRatio, false)) {
    ;; "Unable to liquidate"
    unlock_position(sender_addr, 0, mode::carry_remaining_gas);
    return ();
  }

  int isPartialLiquidation = (spotMarginRatio > db::liquidationFeeRatio) 
  & (db::partialLiquidationRatio > 0)
  & (db::partialLiquidationRatio < DECIMAL_UNIT);
    
  int positionSizeAbs = abs(oldPositionSize);

  int liquidationRatio = 0;
  int liquidationSize = 0;

  ~dump(1);

  if (isPartialLiquidation) {
    liquidationRatio = divd(abs(liquidationSize), positionSizeAbs);
    ;;     int _positionSize,
    ;; int _positionMargin,
    ;; int _positionOpenNotional,
    ;; int _positionLastUpdatedCPF,
    ;; int _positionTimestamp,
    ;; int _option,
    ;; int oraclePrice
    liquidationSize = abs(getPartialLiquidationAmount(
        oldPositionSize,
        oldPositionMargin,
        oldPositionOpenNotional,
        oldPositionLastUpdatedCPF,
        oldPositionTimestamp,
        new_price));
  } else {
    liquidationSize = positionSizeAbs;
  }

  ~dump(2);


  var (
    int newPositionSize,
    int newPositionMargin,
    int newPositionOpenNotional,
    int newPositionLstUpdCPF,
    int positionBadDebt,
    int realizedPnl,
    int marginToTrader,
    int quoteAssetReserveAfter,
    int baseAssetReserveAfter,
    int totalLongAfter,
    int totalShortAfter,
    int totalLongOpenInterestAfter,
    int totalShortOpenInterestAfter,
    int liquidationPenalty,
    _
  ) = internalClosePosition(
    oldPositionSize,
    oldPositionMargin,
    oldPositionOpenNotional,
    oldPositionLastUpdatedCPF,
    oldPositionTimestamp,
    isPartialLiquidation ? liquidationSize : positionSizeAbs,
    db::liquidationFeeRatio,
    0,
    true,
    false,
    true,
    new_price
  );

  ~dump(3);


  int feeToLiquidator = liquidationPenalty / 2;
  int feeToVault = liquidationPenalty - feeToLiquidator;

  int ammBalance = db::balance - liquidationPenalty;
  ;; int newAmmBalance = max(ammBalance, 0);

  db::quoteAssetReserve = quoteAssetReserveAfter;
  db::baseAssetReserve = baseAssetReserveAfter;
  db::totalLongPositionSize = totalLongAfter;
  db::totalShortPositionSize = totalShortAfter;
  db::openInterestLong = totalLongOpenInterestAfter;
  db::openInterestShort = totalShortOpenInterestAfter;
  db::balance = max(ammBalance, 0);

  int withdraw_ton_amount = 120000000; ;; TODO: calculate gas fee from config
  int update_ton_amount = msg_value - withdraw_ton_amount;

  request_withdraw(query_id, feeToLiquidator, liquidator_addr, withdraw_ton_amount, mode::normal);

  cell new_position_ref = pack_position_data(isPartialLiquidation ? (trader_addr, newPositionSize, newPositionMargin, newPositionOpenNotional, newPositionLstUpdCPF, get_position_fee(oldPositionFee), now()) : (trader_addr, 0, 0, 0, 0, 0, 0));
  update_position(new_position_ref, op::liquidate, query_id, sender_addr, update_ton_amount, mode::normal);
  save_data();
}

() handle::oracle_response(slice in_msg_body, slice sender_addr, int my_balance, int msg_value) impure inline {
  load_data();
  throw_unless(error::not_an_oracle, equal_slices(sender_addr, db::oracle_addr));
        

  var (slice prev_sender_addr, int op, int query_id) = (in_msg_body~load_msg_addr(), in_msg_body~load_uint(32), in_msg_body~load_uint(64));

  if (op == op::increase_position) {
    handle::increase_position(in_msg_body, prev_sender_addr, query_id, msg_value);
    return ();
  }

  if (op == op::add_margin) {
    handle::add_margin(in_msg_body, prev_sender_addr, query_id, msg_value);
    return ();
  }
    
  if (op == op::close_position) {
    handle::close_position(in_msg_body, prev_sender_addr, query_id, my_balance, msg_value);
    return ();
  }

  if (op == op::remove_margin) {
    handle::remove_margin(in_msg_body, prev_sender_addr, query_id);
    return ();
  }

  if (op == op::pay_funding) {
    handle::pay_funding(in_msg_body, prev_sender_addr, query_id);
    return ();
  }

  if (op == op::liquidate) {
    handle::liquidate(in_msg_body, prev_sender_addr, query_id, msg_value);
    return ();
  }

  throw(0xffff);
}