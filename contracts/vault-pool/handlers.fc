
#include "../shared/stdlib.fc";

#include "./storage.fc";
#include "./utils.fc";

() handle::add_locked() impure inline {
  load_data();
  int _amount = i.payments[0].amount.usdnToDecimals();
  ;; i.payments[0].assetId != quoteAsset()
  ;; || i.payments.size() != 1
  ;; || !initialized()
  ;; || !(
  ;;   isWhitelist(i.caller.toString()) 
  ;;   || i.caller == adminAddress()
  if (false) {
    ;; throw("Invalid addLocked params")
    return ();
  } 
  
  ;; strict unstake = invoke(
  ;;   managerAddress(),
  ;;   "deposit",
  ;;   [],
  ;;   [AttachedPayment(quoteAsset(), _amount.usdnFromDecimals())]
  ;; )
  ctx::lockedBalance += _amount;
  save_data();
}

() handle::withdraw_locked(_amount: Int) impure inline {
  ;; !initialized()
  ;; || _amount <= 0
  ;; || !(
  ;;   isWhitelist(i.caller.toString())
  ;; )
  if (false) {
    ;; throw("Invalid withdrawLocked params")
    return ();
  } 
    
  int amountOfQuoteAsset = _amount.usdnToDecimals();

  ;; strict unstake = invoke(
  ;;   managerAddress(),
  ;;   "withdraw",
  ;;   [quoteAsset().toBase58String(),  amountOfQuoteAsset.usdnFromDecimals()],
  ;;   []
  ;; )

  ctx::lockedBalance -= amountOfQuoteAsset;
  ;; ++
  ;; [
  ;;   ScriptTransfer(i.caller, amountOfQuoteAsset.usdnFromDecimals(), quoteAsset())
  ;; ]
  save_data();
}

() handle::add_fee(_amount: Int) impure inline {
  int _amount = i.payments[0].amount.usdnToDecimals();
  ;; i.payments[0].assetId != quoteAsset()
  ;; || i.payments.size() != 1
  ;; || !initialized()
  ;; || !(
  ;;   isWhitelist(i.caller.toString()) 
  ;;   || i.caller == adminAddress()
  ;; )
  if (false) {
    ;; throw("Invalid addFree params")
    return ();
  } 

  int newRate = computeNewRate(_amount);

  ;; strict stake = invoke(
  ;;   managerAddress(),
  ;;   "deposit",
  ;;   [],
  ;;   [AttachedPayment(quoteAsset(), _amount.usdnFromDecimals())]
  ;; )
  ctx::freeBalance += _amount;
  ctx::rate = newRate;
  save_data();
}

() exchangeFreeAndLocked(_amount: Int) impure inline {
  ;; Positive amount means withdraw from free and add to locked
  ;; And vice - versa
  ;; !initialized()
  ;; || !isWhitelist(i.caller.toString())
  if (false) {
    ;; throw("Invalid exchangeFreeAndLocked params")
  } 
  int amountOfQuoteAsset = _amount.usdnToDecimals();

  int newRate = computeNewRate(- amountOfQuoteAsset);
      
  updateLockedBalance(amountOfQuoteAsset);
  updateFreeBalance(-amountOfQuoteAsset);
  updateRate(newRate);

  save_data();
}

() handle::stake(slice msg_body) impure inline {
  ;; TODO: check if msg from vault-wallet
  slice stake_s = msg_body.preload_ref();
  int _amount = i.payments[0].amount.usdnToDecimals();
  ;; i.payments[0].assetId != quoteAsset() 
  ;; || i.payments.size() != 1
  ;; || !initialized()
  if (false) {
    ;; throw("Invalid call to stake")
    return ();
  } 
  var (
    newRewardPerTokenStored,
    newLastUpdateTime,
    stakerEarned,
    stakerRewardPerTokenPaid
  ) = updateReward(_staker, 0);

  ;; Do not change the rate, just issue v-Shares and be done with its
  int currentRate = ctx::rate;
  int prevAverageRate = averageRate(_staker);
  int vAmount = _amount.divd(currentRate);
  int newAverageRate = divd(
    vAmount.muld(currentRate) + balanceOf(_staker).muld(prevAverageRate), 
    vAmount + balanceOf(_staker)
  );

  int newTotalBalance = vAmount + balanceOf(_staker);
  int newWithdrawLimit = newTotalBalance.muld(WITHDRAW_PER_PERIOD);

  ;; TODO: send amount to router here
  ;; strict stake = invoke(
  ;;   managerAddress(),
  ;;   "deposit",
  ;;   [],
  ;;   [AttachedPayment(quoteAsset(), _amount.usdnFromDecimals())]
  ;; )

  ;; TODO: update user stake data here:
  ;; updateUserRewards(_staker, stakerEarned, stakerRewardPerTokenPaid)
  ;; updateUserBalance(_staker, vAmount)
  ;; setUserAverageRate(_staker, newAverageRate)
  ;; setUserWithdrawLimit(_staker, newWithdrawLimit)
  
  ctx::rewardPerTokenStored = newRewardPerTokenStored;
  ctx::lastUpdateTime = newLastUpdateTime;
  ctx::freeBalance += _amount;
  ctx::totalSupply += vAmount;
  
  save_data();
}

() handle::unstake(int _amount) inline {
  slice _staker = i.caller.toString();
  int amountOfQuoteAsset = _amount.usdnToDecimals();
  ;; i.payments != []
  ;; || amountOfQuoteAsset <= 0
  ;; || !initialized()
  if (false) {
    ;; throw("Invalid call to unStake")
    return ();
  }   
  var (
    newRewardPerTokenStored,
    newLastUpdateTime,
    stakerEarned,
    stakerRewardPerTokenPaid
  ) = updateReward(_staker, 0);

  ;; Now we determine how much we can withdraw currently
  var (newLastWithdrawnDate, withdrawLimitLeft, alreadyWithdrawnInPeriod) = getWithdrawLimitLeft(_staker);
      
  ;; Get the amount of v-Shares user want to withdraw
  int vAmount = amountOfQuoteAsset.divd(ctx::rate);
  if (vAmount > withdrawLimitLeft) {
    ;; throw("Invalid call to unStake: withdraw over limit")
  } else {
    int newWithdrawnInPeriod = alreadyWithdrawnInPeriod + vAmount;
    ;; strict unstake = invoke(
    ;;   managerAddress(),
    ;;   "withdraw",
    ;;   [quoteAsset().toBase58String(),  amountOfQuoteAsset.usdnFromDecimals()],
    ;;   []
    ;; )

    updateUserRewards(_staker, stakerEarned, stakerRewardPerTokenPaid);
    updateRewardPerTokenStored(newRewardPerTokenStored);
    updateTime(newLastUpdateTime, periodFinish());
    updateFreeBalance(- amountOfQuoteAsset);
    updateUserBalance(_staker, - vAmount);
    updateTotalSupply(- vAmount);
    setUserWithdrawParams(_staker, newLastWithdrawnDate, newWithdrawnInPeriod);
    ;; [
    ;;   ScriptTransfer(i.caller, amountOfQuoteAsset.usdnFromDecimals(), quoteAsset())
    ;; ]
  }
}