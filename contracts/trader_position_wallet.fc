#pragma version >=0.4.1;

#include "shared/stdlib.fc";
#include "shared/messages.fc";

#include "trader_position_wallet/storage.fc";

#include "vamm/op-codes.fc";


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_addr = cs~load_msg_addr();

    int op = in_msg_body.preload_uint(32);

    if ((op == op::increase_position) | (op == op::close_position)) {
        load_data();
        throw_if(400, ctx::is_busy);
        throw_unless(401, equal_slices(sender_addr, ctx::router_addr));

        ctx::is_busy = 1;

        var body = begin_cell().store_slice(in_msg_body).store_ref(ctx::position_ref);
        send_simple_message(0, ctx::vamm_addr, body, mode::carry_remaining_gas);

        save_data();
        return ();
    }

    if (op == op::update_position) {
        load_data();
        throw_unless(400, ctx::is_busy);
        throw_unless(401, equal_slices(sender_addr, ctx::vamm_addr));

        ctx::position_ref = in_msg_body.preload_ref();
        ctx::is_busy = 0;

        send_empty_message(0, ctx::trader_addr, mode::carry_remaining_gas);
        
        save_data();
        return ();
    }

    throw(0xffff); 
}


(slice, slice, slice, int, cell) get_position_data() method_id {
    return load_raw_data();
}